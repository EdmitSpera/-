1、假设一棵非空树采用孩子链存储结构,每个结点值
均为单个字符,完成以下任务：

```java
// 声明树的结构
class TreeNode {
    char val;
    TreeNode firstChild;

    public TreeNode(char val) {
        this.val = val;
        this.firstChild = null;
    }
}
```

(1)设计一个算法求树t中的叶子结点个数。
```java
public static int countLeaves(TreeNode root) {
    if (root == null) {
        return 0;
    } else if (root.firstChild == null) {
        // 如果当前节点没有子节点，则为叶子节点
        return 1;
    } else {
        int count = 0;
        TreeNode child = root.firstChild;
        while (child != null) {
            // 递归地计算每个子节点的叶子节点数
            count += countLeaves(child);
            child = child.nextSibling;
        }
        return count;
    }
}
```
(2)设计一个算法求树t中度为k的结点个数。
```java
public static int countNodesOfDegreeK(TreeNode root, int k) {
    if (root == null) {
        return 0;
    } else if (k == 0 && root.firstChild == null) {
        // 如果要求度为0的节点个数，并且当前节点没有子节点，则当前节点符合条件
        return 1;
    } else {
        int count = 0;
        TreeNode child = root.firstChild;
        while (child != null) {
            // 递归地计算每个子节点的度为k的节点数
            count += countNodesOfDegreeK(child, k - 1);
            child = child.nextSibling;
        }
        return count;
    }
}

```

2、设用于通讯的电文由八个字母组成, 字母在电文中出现的频
率分别为: 8, 10, 5, 19, 30, 15, 11, 28。试为这八个字母设计哈夫曼编码。
```java
import java.util.PriorityQueue;

class Node implements Comparable<Node> {
    char val;
    int frequency;
    Node left;
    Node right;

    public Node(char val, int frequency) {
        this.val = val;
        this.frequency = frequency;
        this.left = null;
        this.right = null;
    }

    @Override
    public int compareTo(Node other) {
        return this.frequency - other.frequency;
    }
}

public class Huffman {
    public static Node buildHuffmanTree(char[] characters, int[] frequencies) {
        PriorityQueue<Node> queue = new PriorityQueue<>();
        for (int i = 0; i < characters.length; i++) {
            queue.offer(new Node(characters[i], frequencies[i]));
        }

        while (queue.size() > 1) {
            Node left = queue.poll();
            Node right = queue.poll();
            Node parent = new Node('\0', left.frequency + right.frequency);
            parent.left = left;
            parent.right = right;
            queue.offer(parent);
        }

        return queue.poll();
    }

    public static void printHuffmanCodes(Node root, String code) {
        if (root == null) {
            return;
        }

        if (root.left == null && root.right == null) {
            System.out.println(root.val + ": " + code);
            return;
        }

        printHuffmanCodes(root.left, code + "0");
        printHuffmanCodes(root.right, code + "1");
    }

    public static void main(String[] args) {
        char[] characters = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'};
        int[] frequencies = {8, 10, 5, 19, 30, 15, 11, 28};

        Node root = buildHuffmanTree(characters, frequencies);
        printHuffmanCodes(root, "");
    }
}

```