# 缓存模式

## 1. Cache Aside Pattern（旁路缓存模式）

**方法描述**
- 应用程序从缓存中读取数据，如果缓存中没有数据（缓存未命中），则从数据库中读取数据，并将数据写入缓存。
- 更新数据时，先更新数据库，再使缓存失效。

**优点**
- 简单易实现
- 适用于读多写少的场景

**缺点**
- 可能导致短暂的不一致（数据库更新成功，但缓存失效失败）
- 缓存失效期间，可能引发缓存雪崩问题

**改进**
- 使用分布式锁控制缓存失效
- 增加缓存失效的重试机制
- 通过缓存预热和设置合理的过期时间，减少缓存雪崩的风险

## 2. Write Through Pattern（直写缓存模式）

**方法描述**
- 应用程序在更新数据时，既更新数据库也更新缓存。

**优点**
- 保证了缓存与数据库的强一致性
- 数据更新时，缓存总是最新的

**缺点**
- 写操作较慢，因为需要同时更新数据库和缓存
- 适用于写多读少的场景

**改进**
- 优化数据库和缓存的更新操作，减少写操作的延迟

## 3. Write Behind Pattern（延迟写缓存模式）

**方法描述**
- 应用程序只更新缓存，后台异步批量更新数据库。

**优点**
- 写操作速度快
- 减少了数据库的写操作压力

**缺点**
- 容易引起数据丢失或不一致（特别是在系统崩溃时）
- 数据最终一致性，无法保证实时性

**改进**
- 使用可靠的消息队列保证缓存到数据库的更新过程
- 定期进行缓存和数据库的数据校验，确保一致性
# 一致性概念
### 强一致性
### 弱一致性
### 最终一致性
# 缓存和数据库一致的问题核心
**删除缓存**时存在线程复写导致脏数据

### 解决
延时第二次删除缓存 尽可能减少“脏缓存数据”的出现
但是这种方式不可能杜绝脏数据

### 保证缓存一致性的常见策略
- 分布式锁

Zookeeper：一种协调服务，用于维护分布式环境中的配置信息、命名、同步和组服务。通过Zookeeper，可以实现分布式锁，从而保证在多个节点上操作的一致性。
Chubby：Google的分布式锁服务，用于解决分布式系统中的一致性问题。
- 事务

两阶段提交 (Two-Phase Commit, 2PC)：一种用于分布式数据库的协议，通过两个阶段（准备阶段和提交阶段）来确保所有参与节点的一致性。虽然2PC能保证强一致性，但在网络分区或节点故障时可能导致系统的可用性下降。
三阶段提交 (Three-Phase Commit, 3PC)：在两阶段提交的基础上增加了一个中间阶段，以提高系统的可用性和减少阻塞的可能性。
- 共识算法

Paxos：一种经典的分布式一致性算法，通过投票机制来达成一致。Paxos保证在出现部分节点故障时，仍能达成一致。
Raft：一种相对易于理解和实现的共识算法，提供和Paxos类似的一致性保证，但在工程实现和理解上更加简洁和清晰。

# 缓存相关重点问题
- 1、什么数据适合被当做缓存
  - 读写占比高的数据
  - 更新较少的数据
- 2、加缓存的位置
  - 浏览器缓存
  - CDN缓存
  - 服务器缓存
  - 本地内存
- 3、一致性的要求：多个副本对一致性的敏感程度
  - 强一致
  - 弱一致
  - 最终一致

### 重点
- 设置过期时间 避免极端情况一直不一致
- 常规业务不追求强一致
- 缓存雪崩 击穿 穿透